目录 
前言
第1章 如何使用本书 1
1.1 本书的基本内容 1
1.2 如何选择编程语言和编译器 1
1.3 在线评测系统 2
1.4 常见的评测结果 3
1.5 如何高效地做题 4
第2章 C/C++快速入门 5
2.1 基本数据类型 7
2.1.1 变量的定义 7
2.1.2 变量类型 7
2.1.3 强制类型转换 11
2.1.4 符号常量和const常量 12
2.1.5 运算符 14
2.2 顺序结构 17
2.2.1 赋值表达式 17
2.2.2 使用scanf和printf输入/输出 18
2.2.3 使用getchar和putchar输入/输出字符 23
2.2.4 注释 24
2.2.5 typedef 24
2.2.6 常用math函数 25
2.3 选择结构 28
2.3.1 if语句 28
2.3.2 if语句的嵌套 31
2.3.3 switch语句 32
2.4 循环结构 34
2.4.1 while语句 34
2.4.2 do while语句 35
2.4.3 for语句 36
2.4.4 break和continue语句 38
2.5 数组 39
2.5.1 一维数组 39
2.5.2 冒泡排序 41
2.5.3 二维数组 43
2.5.4 memset——对数组中每一个元素赋相同的值 46
2.5.5 字符数组 47
2.5.6 string.h头文件 50
2.5.7 sscanf与sprintf 53
2.6 函数 55
2.6.1 函数的定义 55
2.6.2 再谈main函数 58
2.6.3 以数组作为函数参数 58
2.6.4 函数的嵌套调用 59
2.6.5 函数的递归调用 60
2.7 指针 61
2.7.1 什么是指针 61
2.7.2 指针变量 62
2.7.3 指针与数组 63
2.7.4 使用指针变量作为函数参数 65
2.7.5 引用 68
2.8 结构体（struct）的使用 70
2.8.1 结构体的定义 70
2.8.2 访问结构体内的元素 71
2.8.3 结构体的初始化 72
2.9 补充 74
2.9.1 cin与cout 74
2.9.2 浮点数的比较 75
2.9.3 复杂度 78
2.10 黑盒测试 80
2.10.1 单点测试 80
2.10.2 多点测试 80
第3章 入门篇（1）——入门模拟 85
3.1 简单模拟 85
3.2 查找元素 87
3.3 图形输出 89
3.4 日期处理 91
3.5 进制转换 93
3.6 字符串处理 95
第4章 入门篇（2）——算法初步 99
4.1 排序 99
4.1.1 选择排序 99
4.1.2 插入排序 100
4.1.3 排序题与sort函数的应用 101
4.2 散列 106
4.2.1 散列的定义与整数散列 106
4.2.2 字符串hash初步 109
4.3 递归 111
4.3.1 分治 111
4.3.2 递归 112
4.4 贪心 118
4.4.1 简单贪心 118
4.4.2 区间贪心 122
4.5 二分 124
4.5.1 二分查找 124
4.5.2 二分法拓展 131
4.5.3 快速幂 134
4.6 two pointers 137
4.6.1 什么是two pointers 137
4.6.2 归并排序 139
4.6.3 快速排序 142
4.7 其他高效技巧与算法 146
4.7.1 打表 146
4.7.2 活用递推 147
4.7.3 随机选择算法 149
第5章 入门篇（3）——数学问题 152
5.1 简单数学 152
5.2 最大公约数与最小公倍数 154
5.2.1 最大公约数 154
5.2.2 最小公倍数 156
5.3 分数的四则运算 156
5.3.1 分数的表示和化简 157
5.3.2 分数的四则运算 157
5.3.3 分数的输出 159
5.4 素数 159
5.4.1 素数的判断 160
5.4.2 素数表的获取 160
5.5 质因子分解 165
5.6 大整数运算 170
5.6.1 大整数的存储 170
5.6.2 大整数的四则运算 171
5.7 扩展欧几里得算法 176
5.8 组合数 181
5.8.1 关于n!的一个问题 181
5.8.2 组合数的计算 183
第6章 C++标准模板库（STL）介绍 191
6.1 vector的常见用法详解 191
6.2 set的常见用法详解 197
6.3 string的常见用法详解 202
6.4 map的常用用法详解 213
6.5 queue的常见用法详解 218
6.6 priority_queue的常见用法详解 221
6.7 stack的常见用法详解 227
6.8 pair的常见用法详解 230
6.9 algorithm头文件下的常用函数 232
6.9.1 max()、min()和abs() 232
6.9.2 swap() 233
6.9.3 reverse() 233
6.9.4 next_permutation() 234
6.9.5 fill() 235
6.9.6 sort() 235
6.9.7 lower_bound()和upper_bound() 242
第7章 提高篇（1）——数据结构专题（1） 245
7.1 栈的应用 245
7.2 队列的应用 251
7.3 链表处理 253
7.3.1 链表的概念 253
7.3.2 使用malloc函数或new运算符为链表结点分配内存空间 254
7.3.3 链表的基本操作 256
7.3.4 静态链表 260
第8章 提高篇（2）——搜索专题 269
8.1 深度优先搜索（DFS） 269
8.2 广度优先搜索（BFS） 274
第9章 提高篇（3）——数据结构专题（2） 283
9.1 树与二叉树 283
9.1.1 树的定义与性质 283
9.1.2 二叉树的递归定义 284
9.1.3 二叉树的存储结构与基本操作 285
9.2 二叉树的遍历 289
9.2.1 先序遍历 289
9.2.2 中序遍历 290
9.2.3 后序遍历 291
9.2.4 层序遍历 292
9.2.5 二叉树的静态实现 298
9.3 树的遍历 302
9.3.1 树的静态写法 302
9.3.2 树的先根遍历 303
9.3.3 树的层序遍历 303
9.3.4 从树的遍历看DFS与BFS 304
9.4 二叉查找树（BST） 310
9.4.1 二叉查找树的定义 310
9.4.2 二叉查找树的基本操作 310
9.4.3 二叉查找树的性质 314
9.5 平衡二叉树（AVL树） 319
9.5.1 平衡二叉树的定义 319
9.5.2 平衡二叉树的基本操作 320
9.6 并查集 328
9.6.1 并查集的定义 328
9.6.2 并查集的基本操作 328
9.6.3 路径压缩 330
9.7 堆 335
9.7.1 堆的定义与基本操作 335
9.7.2 堆排序 339
9.8 哈夫曼树 342
9.8.1 哈夫曼树 342
9.8.2 哈弗曼编码 345
第10章 提高篇（4）——图算法专题 347
10.1 图的定义和相关术语 347
10.2 图的存储 348
10.2.1 邻接矩阵 348
10.2.2 邻接表 348
10.3 图的遍历 350
10.3.1 采用深度优先搜索（DFS）法遍历图 350
10.3.2 采用广度优先搜索（BFS）法遍历图 359
10.4 最短路径 367
10.4.1 Dijkstra算法 367
10.4.2 Bellman-Ford算法和SPFA算法 391
10.4.3 Floyd算法 398
10.5 最小生成树 400
10.5.1 最小生成树及其性质 400
10.5.2 prim算法 401
10.5.3 kruskal算法 409
10.6 拓扑排序 414
10.6.1 有向无环图 414
10.6.2 拓扑排序 415
10.7 关键路径 417
10.7.1 AOV网和AOE网 417
10.7.2 最长路径 419
10.7.3 关键路径 419
第11章 提高篇（5）——动态规划专题 425
11.1 动态规划的递归写法和递推写法 425
11.1.1 什么是动态规划 425
11.1.2 动态规划的递归写法 425
11.1.3 动态规划的递推写法 426
11.2 最大连续子序列和 429
11.3 最长不下降子序列（LIS） 432
11.4 最长公共子序列（LCS） 434
11.5 最长回文子串 436
11.6 DAG最长路 439
11.7 背包问题 442
11.7.1 多阶段动态规划问题 442
11.7.2 01背包问题 443
11.7.3 完全背包问题 446
11.8 总结 447
第12章 提高篇（6）——字符串专题 449
12.1 字符串hash进阶 449
12.2 KMP算法 455
12.2.1 next数组 456
12.2.2 KMP算法 458
12.2.3 从有限状态自动机的角度看待KMP算法 463
第13章 专题扩展 465
13.1 分块思想 465
13.2 树状数组（BIT） 470
13.2.1 lowbit运算 470
13.2.2 树状数组及其应用 470